<!doctype html>
<html>
<head>
    <style>
		#boxes, #boxes * {
			padding: 0;
			margin: 0;
		}
        #transcr {
            max-width: 50vw;
            max-height: 40vw;
        }
		#boxes {
			display: inline-block;
			position: relative;
			border: 1px solid black;
		}
        .anot {
			display: block;
			position: absolute;
			pointer-events: none;
			border: 2px solid black;
        }
        a {
            text-decoration: none;
        }
    </style>
</head>
<body>
    <h1>
        <%= id %>
        <button id="save">üíæ</button>
        <a href="<%= prev_link %>">‚¨ÖÔ∏è</a>
        <a href="/">‚¨ÜÔ∏è</a>
        <a href="<%= next_link %>">‚û°Ô∏è</a>
    </h1>

    <ul id="meaning_list">
        <%- meanings
                .map(meaning => `<li><meaning-entry value="${meaning}" /></li>`)
                .join('')
        %>
        <li><button>‚ûï</button></li>
    </ul>
	<div id="boxes">
    	<img id="transcr" src="/img/<%=id %>.png"/>
	</div>
    <ul id="symbol_list">
        <%- symbols
                .map(({ name, box }) => `<li><symbol-entry name="${name}"
                    x="${box[0]}" y="${box[1]}" w="${box[2]}" h="${box[3]}" />`)
                .join('')
        %>
    </ul>

    <script>window.onload = function () {
        /* Helper for creating DOM elements */
        function create (parent, tag, attrs, inner) {
            const el = document.createElement(tag);
            for (key in attrs) {
                el.setAttribute(key, attrs[key]);
            }
            if (inner) el.innerHTML = inner;
            parent.appendChild(el);
            return el;
        }

        /* List of meanings for the transcribed sign */

        const meaning_list = document.getElementById("meaning_list");
        const meaning_list_button = document.querySelector("#meaning_list button");
        meaning_list_button.addEventListener("click", function () {
            const li = document.createElement("li");
            li.innerHTML = "<meaning-entry />";
            meaning_list.insertBefore(li, meaning_list.lastElementChild);
        });
        class MeaningEntry extends HTMLElement {
            constructor () {
                super();
                this.text = create(this, 'input', { type: 'text',
                    value: this.getAttribute('value') || '' });
                const del = create(this, 'button', {}, 'üóëÔ∏è');
                del.onclick = () => meaning_list.removeChild(this.parentElement);
            }
        }
        customElements.define('meaning-entry', MeaningEntry);

        /* List of symbols */
        
        const trans = document.getElementById("transcr");
        const boxes_layer = document.getElementById("boxes");
        let current_box = null; // symbol being edited

        const symbol_list = document.getElementById("symbol_list");
        function add_symbol () {
            const li = document.createElement("li");
            li.innerHTML = "<symbol-entry />";
            symbol_list.appendChild(li);
            return li.firstChild;
        }
        const color_list = [ '#FF0000', '#00FF00', '#0000FF', '#FF00FF',
            '#00FFFF', '#880000', '#008800', '#000088', '#888800', '#008888' ];
        let i = 0;
        class SymbolEntry extends HTMLElement {
            constructor () {
                super();
                const color_val = color_list[(i++)%color_list.length];
                const col = create(this, 'input', { type: 'color', value: color_val });
                const text = create(this, 'input', { type: 'text',
					value: this.getAttribute('name') || '' });
                this.text = text;
                const edit = create(this, 'button', {}, 'üìê');
                const del = create(this, 'button', {}, 'üóëÔ∏è');
				const rect = create(boxes_layer, 'span', { class: 'anot' });
                this.rect = rect;
                const x = this.getAttribute('x');
                if (x !== undefined) {
                    const y = this.getAttribute('y');
                    const w = this.getAttribute('w');
                    const h = this.getAttribute('h');
                    const { width, height } = trans.getBoundingClientRect();
                    rect.style.left = Math.round((x-w/2.0)*width)+'px';
                    rect.style.top = Math.round((y-h/2.0)*height)+'px';
                    rect.style.width = Math.round(w*1.0*width)+'px';
                    rect.style.height = Math.round(h*1.0*height)+'px';
                }
				rect.style.borderColor = color_val;
				rect.dirty_box = false;
                boxes_layer.appendChild(rect);
                col.oninput = () => rect.style.borderColor = col.value;
                current_box = rect;
                edit.onclick = () => {
                    rect.style.width = 0;
                    rect.style.height = 0;
                    current_box = rect;
                };
                del.onclick = () => {
                    symbol_list.removeChild(this.parentElement);
                    boxes_layer.removeChild(rect);
                };
            }
        }
        customElements.define('symbol-entry', SymbolEntry);

        /* Bounding boxes of symbols */

        let draw = null;
        trans.addEventListener('mousedown', e => {
            if (!current_box) add_symbol();
			current_box.dirty_box = true;
            const { left, top } = trans.getBoundingClientRect();
            const x = e.clientX - left;
            const y = e.clientY - top;
            draw = { x, y };
            current_box.style.left = x+'px';
            current_box.style.top = y+'px';
            current_box.style.width = 0;
            current_box.style.height = 0;
            e.preventDefault();
        });
        trans.addEventListener('mousemove', e => {
            if (draw !== null) {
                const { left, top } = trans.getBoundingClientRect();
                const x = e.clientX - left;
                const y = e.clientY - top;
                if (x >= draw.x) {
                    current_box.style.left = draw.x+'px';
                    current_box.style.width = x-draw.x+'px';
                } else {
                    current_box.style.left = x+'px';
                    current_box.style.width = draw.x-x+'px';
                }
                if (y >= draw.y) {
                    current_box.style.top = draw.y+'px';
                    current_box.style.height = y-draw.y+'px';
                } else {
                    current_box.style.top = y+'px';
                    current_box.style.height = draw.y-y+'px';
                }
            }
        });
        document.addEventListener('mouseup', () => {
            current_box = null;
            draw = null;
        });

		current_box = null;

        document.getElementById("save").onclick = function () {
            const data = {
                meanings: [],
                symbols: []
            };
            meaning_list.querySelectorAll("meaning-entry").forEach(m => {
                data.meanings.push(m.text.value);
            });
			const { left: off_x, top: off_y } = trans.getBoundingClientRect();
			const { clientWidth: off_w, clientHeight: off_h } = trans;
            symbol_list.querySelectorAll("symbol-entry").forEach(s => {
				let box;
				if (s.rect.dirty_box) {
                	const r = s.rect.getBoundingClientRect();
					const { clientWidth: w, clientHeight: h } = s.rect;
                    box = [ (r.left+w/2.0-off_x)/off_w,
                        (r.top+h/2.0-off_y)/off_h,
                        w*1.0/off_w, h*1.0/off_h ];
				} else {
					box = [ s.getAttribute('x'), s.getAttribute('y'),
							s.getAttribute('w'), s.getAttribute('h') ];
				}
                data.symbols.push({ name: s.text.value, box });
            });
            fetch(window.location, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(r => alert(r.ok?"OK":`Error: ${r.statusText}`))
            .catch(e => alert(`Error: ${e}`));
        }
    }</script>
</body>
</html>
